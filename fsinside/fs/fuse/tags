!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BLKNO_INVALID	buf.h	13;"	d
BLOCK_SIZE	tinyfs.h	18;"	d
BOOL	buf.h	/^typedef int BOOL;$/;"	t
BUF_LIST_CLEAN	buf.h	/^    BUF_LIST_CLEAN,$/;"	e	enum:__BufList
BUF_LIST_DIRTY	buf.h	/^    BUF_LIST_DIRTY,$/;"	e	enum:__BufList
BUF_LIST_FREE	buf.h	/^    BUF_LIST_FREE$/;"	e	enum:__BufList
BUF_STATE_CLEAN	buf.h	/^	BUF_STATE_CLEAN,$/;"	e	enum:__BufState
BUF_STATE_DIRTY	buf.h	/^	BUF_STATE_DIRTY$/;"	e	enum:__BufState
Buf	buf.h	/^struct Buf$/;"	s
Buf	buf.h	/^typedef struct Buf Buf;$/;"	t	typeref:struct:Buf
BufDelete	buf.c	/^BOOL BufDelete(Buf* pBuf)$/;"	f
BufFind	buf.c	/^Buf* BufFind(int blkno)$/;"	f
BufGetNewBuffer	buf.c	/^Buf* BufGetNewBuffer(void)$/;"	f
BufInsert	buf.c	/^void BufInsert(Buf* pBuf, BufList listNum)$/;"	f
BufList	buf.h	/^} BufList;$/;"	t	typeref:enum:__BufList
BufRead	buf.c	/^Buf* BufRead(int blkno)$/;"	f
BufState	buf.h	/^} BufState;$/;"	t	typeref:enum:__BufState
BufSync	buf.c	/^void BufSync(void)$/;"	f
BufWrite	buf.c	/^BOOL BufWrite(Buf* pBuf, void* pData, int size)$/;"	f
DecUseBlock	fs.c	/^int DecUseBlock()	\/\/ Block 1개 해제$/;"	f
DecUseInode	fs.c	/^int DecUseInode()	\/\/ Inode 1개 해제$/;"	f
DevInit	disk.c	/^void DevInit(void)$/;"	f
DevLoad	disk.c	/^void DevLoad(void)$/;"	f
DevMoveBlock	disk.c	/^void DevMoveBlock(int blkno){$/;"	f
DevReadBlock	disk.c	/^void DevReadBlock(int blkno, char* pBuf)$/;"	f
DevRelease	disk.c	/^void DevRelease(void)$/;"	f
DevWriteBlock	disk.c	/^void DevWriteBlock(int blkno, char* pBuf)$/;"	f
DirIsEmpty	fs.c	/^int DirIsEmpty(tiny_inode* inodeInfo)$/;"	f
FALSE	buf.h	14;"	d
FILE_TYPE_DIR	tinyfs.h	/^    FILE_TYPE_DIR,$/;"	e	enum:__anon3
FILE_TYPE_FILE	tinyfs.h	/^    FILE_TYPE_FILE,$/;"	e	enum:__anon3
FS_DISK_CAPACITY	tinyfs.h	16;"	d
FS_INODE_COUNT	tinyfs.h	17;"	d
FUSE_USE_VERSION	tinyfs.h	4;"	d
FileSysInfo	tinyfs.h	/^} FileSysInfo;$/;"	t	typeref:struct:__anon2
FileType	tinyfs.h	/^} FileType;$/;"	t	typeref:enum:__anon3
GetBufInfoByHashIndex	buf.c	/^void GetBufInfoByHashIndex(int index, Buf** ppObjInfo, int* pNumBuf)$/;"	f
GetBufInfoByListNum	buf.c	/^void GetBufInfoByListNum(BufList listNum, Buf** ppObjInfo, int* pNumBuf)$/;"	f
GetEntryName	fs.c	/^int GetEntryName(char* dest, char* abspath)$/;"	f
GetEntryPath	fs.c	/^void GetEntryPath(char* abspath, char* filename)$/;"	f
GetFreeBlock	fs.c	/^int GetFreeBlock()$/;"	f
GetFreeDir	fs.c	/^int GetFreeDir(tiny_dirblk* dirBlock)$/;"	f
GetFreeEntry	fs.c	/^int GetFreeEntry(char* Bitmap, int BitmapBlockSize)$/;"	f
GetFreeInode	fs.c	/^int GetFreeInode()$/;"	f
HASH_TBL_SIZE	buf.h	11;"	d
IncUseBlock	fs.c	/^int IncUseBlock()	\/\/ Block 1개 사용$/;"	f
IncUseInode	fs.c	/^int IncUseInode()	\/\/ Inode 1개 사용$/;"	f
Init	buf.c	/^void Init(void)$/;"	f
InitObjectLink	buf.c	/^void InitObjectLink(Buf* pBuf)$/;"	f
InsertBufIntoFreelist	buf.c	/^void InsertBufIntoFreelist(Buf* pBuf)$/;"	f
MAX_BUFLIST_NUM	buf.h	12;"	d
MAX_INDEX_OF_DIRBLK	tinyfs.h	21;"	d
MT_TYPE_FORMAT	tinyfs.h	/^	MT_TYPE_FORMAT,     \/\/ 마운트가 되는 해당 파티션은 포맷된다. $/;"	e	enum:__anon1
MT_TYPE_READWRITE	tinyfs.h	/^	MT_TYPE_READWRITE,  \/\/ 마운트가 되는 해당 파티션은 그대로 유지된다. $/;"	e	enum:__anon1
MT_TYPE_UNKNOWN	tinyfs.h	/^	MT_TYPE_UNKNOWN = 0,$/;"	e	enum:__anon1
MakeDirentry	fs.c	/^int MakeDirentry(tiny_inode* inodeInfo, char* dirname)$/;"	f
MountType	tinyfs.h	/^} MountType; $/;"	t	typeref:enum:__anon1
NAME_LEN_MAX	tinyfs.h	22;"	d
NUM_OF_DIRENT_IN_1BLK	tinyfs.h	20;"	d
NUM_OF_INODE_IN_1BLK	tinyfs.h	19;"	d
OBJ	Makefile	/^OBJ = $(patsubst %.c, %.o, $(SRC))$/;"	m
OPT	Makefile	/^OPT = -lfuse -D_FILE_OFFSET_BITS=64 -lm -g$/;"	m
ReadDirBlock	fs.c	/^void ReadDirBlock(tiny_dirblk* dirBlock, int blockNo)$/;"	f
ReadInode	fs.c	/^void ReadInode(tiny_inode* inodeInfo, int inodeNo)$/;"	f
RemoveDirentry	fs.c	/^int RemoveDirentry(tiny_inode* inodeInfo, char* dirname)$/;"	f
SRC	Makefile	/^SRC = $(wildcard *.c)$/;"	m
SetBlockAllocToFree	fs.c	/^int SetBlockAllocToFree(int blockno)$/;"	f
SetBlockFreeToAlloc	fs.c	/^int SetBlockFreeToAlloc()$/;"	f
SetFreeToAlloc	fs.c	/^int SetFreeToAlloc(char* Bitmap, int BitmapBlockSize)$/;"	f
SetInodeAllocToFree	fs.c	/^int SetInodeAllocToFree(int inodeno)$/;"	f
SetInodeFreeToAlloc	fs.c	/^int SetInodeFreeToAlloc()$/;"	f
TARGET	Makefile	/^TARGET = tinyfs$/;"	m
TINY_N_DIRECT_BLOCKS	tinyfs.h	23;"	d
TRUE	buf.h	15;"	d
WRONG_VALUE	buf.h	16;"	d
WriteDirBlock	fs.c	/^void WriteDirBlock(tiny_dirblk* dirBlock, int blockNo)$/;"	f
WriteInode	fs.c	/^void WriteInode(tiny_inode* inodeInfo, int inodeNo)$/;"	f
_TINYFS_H_	tinyfs.h	2;"	d
__BUF_H__	buf.h	2;"	d
__BufList	buf.h	/^typedef enum __BufList{$/;"	g
__BufState	buf.h	/^typedef enum __BufState$/;"	g
__DISK_H__	disk.h	2;"	d
__FILESYSTEM_H__	fs.h	2;"	d
__create_file	op_create.c	/^static int __create_file(tiny_inode *parent_inode, const char *name)$/;"	f	file:
__find_dentry	ops.c	/^tiny_dentry *__find_dentry(tiny_inode *dir, const char *entry_name)$/;"	f
__find_dentry_and_remove	op_unlink.c	/^static int __find_dentry_and_remove(tiny_inode* out_inode, $/;"	f	file:
__find_inodeno_for_dir	ops.c	/^int __find_inodeno_for_dir(tiny_inode *dir) {$/;"	f
__get_dirblk_from_buf	tinyfs.h	79;"	d
blkno	buf.h	/^    int					blkno;$/;"	m	struct:Buf
dirEntries	tinyfs.h	/^	tiny_dentry	dirEntries[NUM_OF_DIRENT_IN_1BLK];$/;"	m	struct:__anon6
hash	buf.h	/^    TAILQ_ENTRY(Buf)	hash;$/;"	m	struct:Buf
i_block	tinyfs.h	/^	int			i_block[TINY_N_DIRECT_BLOCKS];$/;"	m	struct:__anon4
i_nblk	tinyfs.h	/^	int			i_nblk;$/;"	m	struct:__anon4
i_size	tinyfs.h	/^	int			i_size;$/;"	m	struct:__anon4
i_type	tinyfs.h	/^	FileType	i_type;$/;"	m	struct:__anon4
inodeNum	tinyfs.h	/^    unsigned	inodeNum;$/;"	m	struct:__anon5
link	buf.h	/^    TAILQ_ENTRY(Buf)	link;$/;"	m	struct:Buf
main	main.c	/^int main(int argc, char *argv[])$/;"	f
name	tinyfs.h	/^    char 		name[NAME_LEN_MAX];$/;"	m	struct:__anon5
pMem	buf.h	/^    void*				pMem;$/;"	m	struct:Buf
s_blksize	tinyfs.h	/^	int s_blksize;$/;"	m	struct:__anon2
s_datablk_size	tinyfs.h	/^	int	s_datablk_size;$/;"	m	struct:__anon2
s_datablk_start	tinyfs.h	/^	int s_datablk_start;			\/\/ data 영역의 시작 블록 번호$/;"	m	struct:__anon2
s_dbitmap_ptr	tinyfs.h	/^	char* s_dbitmap_ptr; 	\/\/ block bitmap 정보가 저장된 메모리 주소$/;"	m	struct:__anon2
s_dbitmap_size	tinyfs.h	/^	int	s_dbitmap_size;$/;"	m	struct:__anon2
s_dbitmap_start	tinyfs.h	/^	int s_dbitmap_start;	\/\/ block bitmap이 저장된 블록 번호$/;"	m	struct:__anon2
s_disk_fd	tinyfs.h	/^	int s_disk_fd; $/;"	m	struct:__anon2
s_ibitmap_ptr	tinyfs.h	/^	char* s_ibitmap_ptr; 	\/\/ inode bitmap 정보가 저장된 메모리 주소$/;"	m	struct:__anon2
s_ibitmap_size	tinyfs.h	/^	int	s_ibitmap_size;$/;"	m	struct:__anon2
s_ibitmap_start	tinyfs.h	/^	int s_ibitmap_start;	\/\/ inode bitmap이 저장된 블록의 번호$/;"	m	struct:__anon2
s_inodeblk_size	tinyfs.h	/^	int	s_inodeblk_size;$/;"	m	struct:__anon2
s_inodeblk_start	tinyfs.h	/^	int s_inodeblk_start;		\/\/ inode list를 저장하는 영역의 시작 블록 번호$/;"	m	struct:__anon2
s_nblk	tinyfs.h	/^	int s_nblk;				\/\/ 파일 시스템의 설정된 블록 크기$/;"	m	struct:__anon2
s_nblk_free	tinyfs.h	/^	int s_nblk_free;		\/\/ 할당되지 않은 블록 개수$/;"	m	struct:__anon2
s_nblk_use	tinyfs.h	/^	int s_nblk_use;		\/\/ 할당된 블록 개수$/;"	m	struct:__anon2
s_ndatablk	tinyfs.h	/^	int s_ndatablk;		\/\/ 디스크의 용량. 블록 개수로 저장됨$/;"	m	struct:__anon2
s_ninode	tinyfs.h	/^	int s_ninode;			\/\/ 전체 inode의 개수$/;"	m	struct:__anon2
s_ninode_free	tinyfs.h	/^	int s_ninode_free;		\/\/ 할당되지 않은 inode의 개수$/;"	m	struct:__anon2
s_ninode_in_blk	tinyfs.h	/^	int s_ninode_in_blk;$/;"	m	struct:__anon2
s_ninode_use	tinyfs.h	/^	int s_ninode_use;		\/\/ 할당된 inode의 개수$/;"	m	struct:__anon2
s_rdirino	tinyfs.h	/^	int s_rdirino; 		\/\/ root inode number 저장$/;"	m	struct:__anon2
state	buf.h	/^    BufState			state;$/;"	m	struct:Buf
tiny_create	op_create.c	/^int tiny_create(const char *path, mode_t mode, struct fuse_file_info *fi)$/;"	f
tiny_dentry	tinyfs.h	/^} tiny_dentry;$/;"	t	typeref:struct:__anon5
tiny_destroy	op_destroy.c	/^void tiny_destroy(void *user_data)$/;"	f
tiny_dirblk	tinyfs.h	/^} tiny_dirblk;$/;"	t	typeref:struct:__anon6
tiny_getattr	op_getattr.c	/^int tiny_getattr(const char *path, struct stat *stbuf)$/;"	f
tiny_init	op_init.c	/^void *tiny_init(struct fuse_conn_info *conn)$/;"	f
tiny_inode	tinyfs.h	/^} tiny_inode;$/;"	t	typeref:struct:__anon4
tiny_mkdir	op_mkdir.c	/^int tiny_mkdir(const char *path, mode_t mode)$/;"	f
tiny_open	op_open.c	/^int tiny_open(const char *path, struct fuse_file_info *fi)$/;"	f
tiny_ops	main.c	/^static struct fuse_operations tiny_ops = {$/;"	v	typeref:struct:fuse_operations	file:
tiny_read	op_read.c	/^int tiny_read(const char *path, char *buf, size_t size,$/;"	f
tiny_readdir	op_readdir.c	/^int tiny_readdir(const char *path, void *buf, fuse_fill_dir_t filler,$/;"	f
tiny_release	ops.c	/^int tiny_release(const char *path, struct fuse_file_info *info)$/;"	f
tiny_releasedir	ops.c	/^int tiny_releasedir(const char *path, struct fuse_file_info *info)$/;"	f
tiny_rename	ops.c	/^int tiny_rename(const char *before, const char *after)$/;"	f
tiny_rmdir	op_rmdir.c	/^int tiny_rmdir(const char *path)$/;"	f
tiny_superblk	main.c	/^FileSysInfo tiny_superblk;$/;"	v
tiny_truncate	op_truncate.c	/^int tiny_truncate(const char *path, off_t size)$/;"	f
tiny_unlink	op_unlink.c	/^int tiny_unlink(const char *path)$/;"	f
tiny_utimens	ops.c	/^int tiny_utimens(const char *path, const struct timespec tv[2])$/;"	f
tiny_write	op_write.c	/^int tiny_write(const char *path, const char *buf, size_t size,$/;"	f
type	tinyfs.h	/^    FileType	type;$/;"	m	struct:__anon5
